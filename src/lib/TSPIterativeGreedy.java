/* Copyright 2016 Aellison Cassimiro
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
package lib;

import java.io.File;
import java.util.*;

import java.io.*;

import org.moeaframework.problem.tsplib.DistanceTable;
import org.moeaframework.problem.tsplib.TSPInstance;
import org.moeaframework.problem.tsplib.Tour;

public class TSPIterativeGreedy {


	private int numIterat;
	private TSPInstance instance;
	private Tour tour;
	private Tour finalTour;
	private double bestFitness;
	private double finalFitness;
	private Tour bestTour;
	private ArrayList<Tour> tourList;

	/**
	  * Constructs a new TSPIterativeGreedy instance
	  */
	public TSPIterativeGreedy(){
		bestFitness = Double.MAX_VALUE;
		tourList = new ArrayList<Tour>();
	}


	/**
	 * Getter of the numIterat attribute. 
	 * 
	 * @return the number of iterations done in the IG function
	 */
	public int getNumIterat(){
		return this.numIterat;

	}

	/**
	 * Getter of the bestFitness attribute. 
	 * 
	 * @return the best fitness for this instance
	 */
	public double getBestFitness(){
		return this.bestFitness;

	}

	/**
	 * Getter of the bestTour attribute. 
	 * 
	 * @return the tour with the best fitness generated by this instance
	 */
	public Tour getBestTour(){
		return this.bestTour;
	}

	/**
	 * Getter of the finalTour attribute. 
	 * 
	 * @return the fitness of the last tour generated by this instance
	 */
	public Tour getFinalTour(){
		return this.finalTour;
	}

	/**
	 * Getter of the tourList attribute. 
	 * 
	 * @return an ArrayList of tours generated by this instance
	 */
	public ArrayList<Tour> getTourList(){
		return this.tourList;
	}

	/**
	 * Getter of the tour attribute. 
	 * 
	 * @return the current tour generated by the instance
	 */
	public Tour getTour(){
	    return this.tour;
	}

	/**
	 * Based on the current tour, this method will generate the fitness
	 * of this tour. 
	 * 
	 * @return the fitness of the current tour
	 */
	public double getCurrentFitness(){
		DistanceTable graph = instance.getDistanceTable();
		int []path = tour.toArray();
		double fitness = 0;

		for(int i = 0; i < graph.listNodes().length - 1; i++){
			fitness += graph.getDistanceBetween(path[i], path[i+1]); 
		}
			
		return fitness;
	}

	/**
	 * Creates an array of integers representing the path that must be rebuilt.
	 * This array will have the size of the destructionFactor, which is the size
	 * of the part of the tour to be destroyed/rebuilt.  
	 * 
	 * @param starting node where the metaheuristic will be applied
	 * @param destruction factor of this instance (size of the destroyed area)
	 * @param nodes which are already in the solution
	 * @return the fitness of the last tour generated by this instance
	 */
	public int[] createPath(int begin, int destructionFactor, int[] visited){
		int [] path = new int[destructionFactor];
		ArrayList<Integer> pathList = new ArrayList();
		int currentNode, nextNode;
		double lower, distance;

		List<Integer> visitedList = new ArrayList<Integer>(visited.length);

		for (int i=0; i<visited.length; i++){
		    visitedList.add(visited[i]);
		}

		DistanceTable graph = instance.getDistanceTable();

		int []neighbors;

		currentNode = begin;
		while(true){
			neighbors = graph.getNeighborsOf(currentNode);

			if(pathList.size() == destructionFactor){
				break;
			}

			lower = Double.MAX_VALUE;
			nextNode = -1;

			for(int i = 0; i < neighbors.length; i++){
				distance = graph.getDistanceBetween(currentNode, neighbors[i]);
				
				if((lower > distance) && !(visitedList.contains(neighbors[i]))){
					lower = distance;
					nextNode = neighbors[i];
				}
			}

			if(nextNode == -1){
				System.out.println("ERROR: NO PATH FOUND");
				System.exit(0);
			}

			visitedList.add(nextNode);
			pathList.add(nextNode);
			currentNode = nextNode;

		}


		for(int i = 0; i < path.length; i++){
			path[i] = pathList.get(i);
		}

		return path;
	}

	int lastDPoint = -1;
	/**
	 * Ruins 30% of a solution at a random point. The same point cannot be ruined
	 * two times in a row. Calls the createPath function in order to obtain the 
	 * rebuilt path and concatenate the not ruined parts with the rebuilt path.
	 * 
	 * @param a tour to be ruined/rebuilt
	 * @return the rebuilt tour
	 */
	public Tour rebuildTour(Tour originalTour){
		int []arrTour = originalTour.toArray();
		int destructionFactor;
		int destructionPoint;
		int i;
		int []ruinedArrayTour;
		int []rebuiltPath;
		int currentRandom = 0;

		Random r = new Random();

		destructionFactor = (int) (arrTour.length * 0.3);

		destructionPoint = (int) (arrTour.length * (r.nextInt(7)) * 0.1);
		while(lastDPoint == destructionPoint){
			destructionPoint = (int) (arrTour.length * (r.nextInt(7)) * 0.1);
		}

		lastDPoint = destructionPoint;
		
		ruinedArrayTour = new int[arrTour.length - destructionFactor];

		for(i = 0; i < destructionPoint; i ++){
			ruinedArrayTour[i] = arrTour[i];	
		}

		for(; i < ruinedArrayTour.length; i++){
			ruinedArrayTour[i] = arrTour[i + destructionFactor];
		}
		
		if (destructionPoint == 0) {
			rebuiltPath = createPath(ruinedArrayTour[destructionPoint], destructionFactor,ruinedArrayTour);
		} else {
			rebuiltPath = createPath(ruinedArrayTour[destructionPoint - 1], destructionFactor,ruinedArrayTour);
		}

		for(i = 0; i < destructionPoint; i++) {
			arrTour[i] = ruinedArrayTour[i]; 
		}

		for(i = 0; i < destructionFactor; i++) {
			arrTour[i + destructionPoint] = rebuiltPath[i]; 
		}

		for(i = destructionPoint + destructionFactor; i < arrTour.length; i++) { 
			arrTour[i] = ruinedArrayTour[i - destructionFactor]; 
		}

		originalTour.fromArray(arrTour);

		return originalTour;
	}

	/**
	 * Reads optimal path file, returns the optimal distance
	 * 
	 * @param name of the input instance
	 * @param optimal distance of the instance
	 */
	public double getOpt(String path){
		TSPInstance temp;
		double optDist = 0;

		try {
            temp = new TSPInstance(new File("tsp-instances/" + path));

            temp.addTour(new File("tsp-instances/" + path.split("\\.")[0] + ".opt.tour"));
            optDist = temp.getTours().get(0).distance(temp);

  		} catch (IOException e) {
        	System.out.println("File not found");
        	System.exit(1);
        }
        
        return optDist;
	}


	/**
	 * The core of the TSPIterativeGreedy class. It runs the tests, getting the 
	 * tours beign iterated and its fitnesses. All values are respectively stored in
	 * the instance object variables to be used with the "get" funcions.
	 * 
	 * @param name of the input instance
	 * @param num of iterations of instances tested by the algorithm
	 * @param time limit to a set of iterations
	 */
	public void IG(String path, int poolSize, int timeLimit){

		path += ".tsp";

		int counter = 0;		
		double fitness = 0;
		long beginTime, endTime;
		instance = new TSPInstance();


		File instanceFile = new File("tsp-instances/" + path);
		double optDist = getOpt(path);


		instance.getDistanceTable();

		try{
			instance.load(instanceFile);
		} catch (Exception e){
			System.out.println("Erro no arquivo");
			System.exit(0);
		}

		DistanceTable grafo = instance.getDistanceTable();
		
		while (counter++ < poolSize) {
			lastDPoint = -1;
			tour = Tour.createRandomTour(instance.getDimension());

			long time = System.currentTimeMillis(); 
			while(System.currentTimeMillis() - time <= (timeLimit * 1000)){
				tour = rebuildTour(tour);

				fitness = getCurrentFitness();

				if(fitness < bestFitness){
					bestFitness = fitness;
					bestTour = this.tour;
				} else if (fitness == optDist) {
					break;
				}
				numIterat++;
				tourList.add(this.tour);
			}

			finalFitness = fitness;
			finalTour = tour;

		}
	} 

}
